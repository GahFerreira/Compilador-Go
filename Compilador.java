/* Generated By:JavaCC: Do not edit this line. Compilador.java */
public class Compilador implements CompiladorConstants {
  public static void main(String args[]) throws ParseException, TokenMgrError
  {
    Compilador parser = new Compilador(System.in);

    parser.Inicio();
  }

  static final public void Inicio() throws ParseException {
  Token t;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOKEN_GENERAL_COMMENT:
      case TOKEN_RAW_STRING_LITERAL:
      case TOKEN_INTERPRETED_STRING_LITERAL:
      case TOKEN_ANY:
      case TOKEN_BOOL:
      case TOKEN_BYTE:
      case TOKEN_COMPARABLE:
      case TOKEN_COMPLEX64:
      case TOKEN_COMPLEX128:
      case TOKEN_ERROR:
      case TOKEN_FLOAT32:
      case TOKEN_FLOAT64:
      case TOKEN_INT:
      case TOKEN_INT8:
      case TOKEN_INT16:
      case TOKEN_INT32:
      case TOKEN_INT64:
      case TOKEN_RUNE:
      case TOKEN_STRING:
      case TOKEN_UINT:
      case TOKEN_UINT8:
      case TOKEN_UINT16:
      case TOKEN_UINT32:
      case TOKEN_UINT64:
      case TOKEN_UINTPTR:
      case TOKEN_TRUE:
      case TOKEN_FALSE:
      case TOKEN_IOTA:
      case TOKEN_APPEND:
      case TOKEN_CAP:
      case TOKEN_CLOSE:
      case TOKEN_COMPLEX:
      case TOKEN_COPY:
      case TOKEN_DELETE:
      case TOKEN_IMAG:
      case TOKEN_LEN:
      case TOKEN_MAKE:
      case TOKEN_NEW:
      case TOKEN_PANIC:
      case TOKEN_PRINTLN:
      case TOKEN_PRINT:
      case TOKEN_REAL:
      case TOKEN_RECOVER:
      case TOKEN_BREAK:
      case TOKEN_DEFAULT:
      case TOKEN_FUNC:
      case TOKEN_INTERFACE:
      case TOKEN_SELECT:
      case TOKEN_CASE:
      case TOKEN_DEFER:
      case TOKEN_GO:
      case TOKEN_MAP:
      case TOKEN_STRUCT:
      case TOKEN_CHAN:
      case TOKEN_ELSE:
      case TOKEN_GOTO:
      case TOKEN_PACKAGE:
      case TOKEN_SWITCH:
      case TOKEN_CONST:
      case TOKEN_FALLTHROUGH:
      case TOKEN_IF:
      case TOKEN_RANGE:
      case TOKEN_TYPE:
      case TOKEN_CONTINUE:
      case TOKEN_FOR:
      case TOKEN_IMPORT:
      case TOKEN_RETURN:
      case TOKEN_VAR:
      case TOKEN_NIL:
      case TOKEN_LINE_COMMENT:
      case TOKEN_DIFFERENT:
      case TOKEN_LESS_EQUAL:
      case TOKEN_GREATER_EQUAL:
      case TOKEN_SHORT_DECLARATION:
      case TOKEN_ELLIPSIS:
      case TOKEN_OPEN_PARENTHESIS:
      case TOKEN_CLOSE_PARENTHESIS:
      case TOKEN_OPEN_BRACKET:
      case TOKEN_CLOSE_BRACKET:
      case TOKEN_OPEN_BRACE:
      case TOKEN_CLOSE_BRACE:
      case TOKEN_COMMA:
      case TOKEN_SEMICOLON:
      case TOKEN_DOT:
      case TOKEN_COLON:
      case TOKEN_AND:
      case TOKEN_OR:
      case TOKEN_CHANNEL_DIRECTION:
      case TOKEN_PLUS_PLUS:
      case TOKEN_MINUS_MINUS:
      case TOKEN_BIT_AND_NOT_ASSIGN:
      case TOKEN_BIT_AND_ASSIGN:
      case TOKEN_BIT_OR_ASSIGN:
      case TOKEN_BIT_XOR_ASSIGN:
      case TOKEN_LEFT_SHIFT_ASSIGN:
      case TOKEN_RIGHT_SHIFT_ASSIGN:
      case TOKEN_PLUS_ASSIGN:
      case TOKEN_MINUS_ASSIGN:
      case TOKEN_MULTIPLY_ASSIGN:
      case TOKEN_DIVIDE_ASSIGN:
      case TOKEN_REMAINDER_ASSIGN:
      case TOKEN_BIT_AND_NOT:
      case TOKEN_BIT_AND:
      case TOKEN_BIT_OR:
      case TOKEN_BIT_XOR:
      case TOKEN_LEFT_SHIFT:
      case TOKEN_RIGHT_SHIFT:
      case TOKEN_PLUS:
      case TOKEN_MINUS:
      case TOKEN_MULTIPLY:
      case TOKEN_DIVIDE:
      case TOKEN_REMAINDER:
      case TOKEN_EQUAL:
      case TOKEN_LESS:
      case TOKEN_GREATER:
      case TOKEN_ASSIGN:
      case TOKEN_NOT:
      case TOKEN_TILDE:
      case TOKEN_BINARY_LITERAL:
      case TOKEN_OCTAL_LITERAL:
      case TOKEN_DECIMAL_LITERAL:
      case TOKEN_HEX_LITERAL:
      case TOKEN_DECIMAL_FLOAT_LITERAL:
      case TOKEN_HEX_FLOAT_LITERAL:
      case TOKEN_IMAGINARY_LITERAL:
      case TOKEN_RUNE_LITERAL:
      case TOKEN_IDENTIFIER:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOKEN_ANY:
        t = jj_consume_token(TOKEN_ANY);
      System.out.println("TOKEN_ANY " + t.image);
        break;
      case TOKEN_BOOL:
        t = jj_consume_token(TOKEN_BOOL);
      System.out.println("TOKEN_BOOL " + t.image);
        break;
      case TOKEN_BYTE:
        t = jj_consume_token(TOKEN_BYTE);
      System.out.println("TOKEN_BYTE " + t.image);
        break;
      case TOKEN_COMPARABLE:
        t = jj_consume_token(TOKEN_COMPARABLE);
      System.out.println("TOKEN_COMPARABLE " + t.image);
        break;
      case TOKEN_COMPLEX64:
        t = jj_consume_token(TOKEN_COMPLEX64);
      System.out.println("TOKEN_COMPLEX64 " + t.image);
        break;
      case TOKEN_COMPLEX128:
        t = jj_consume_token(TOKEN_COMPLEX128);
      System.out.println("TOKEN_COMPLEX128 " + t.image);
        break;
      case TOKEN_ERROR:
        t = jj_consume_token(TOKEN_ERROR);
      System.out.println("TOKEN_ERROR " + t.image);
        break;
      case TOKEN_FLOAT32:
        t = jj_consume_token(TOKEN_FLOAT32);
      System.out.println("TOKEN_FLOAT32 " + t.image);
        break;
      case TOKEN_FLOAT64:
        t = jj_consume_token(TOKEN_FLOAT64);
      System.out.println("TOKEN_FLOAT64 " + t.image);
        break;
      case TOKEN_INT:
        t = jj_consume_token(TOKEN_INT);
      System.out.println("TOKEN_INT " + t.image);
        break;
      case TOKEN_INT8:
        t = jj_consume_token(TOKEN_INT8);
      System.out.println("TOKEN_INT8 " + t.image);
        break;
      case TOKEN_INT16:
        t = jj_consume_token(TOKEN_INT16);
      System.out.println("TOKEN_INT16 " + t.image);
        break;
      case TOKEN_INT32:
        t = jj_consume_token(TOKEN_INT32);
      System.out.println("TOKEN_INT32 " + t.image);
        break;
      case TOKEN_INT64:
        t = jj_consume_token(TOKEN_INT64);
      System.out.println("TOKEN_INT64 " + t.image);
        break;
      case TOKEN_RUNE:
        t = jj_consume_token(TOKEN_RUNE);
      System.out.println("TOKEN_RUNE " + t.image);
        break;
      case TOKEN_STRING:
        t = jj_consume_token(TOKEN_STRING);
      System.out.println("TOKEN_STRING " + t.image);
        break;
      case TOKEN_UINT:
        t = jj_consume_token(TOKEN_UINT);
      System.out.println("TOKEN_UINT " + t.image);
        break;
      case TOKEN_UINT8:
        t = jj_consume_token(TOKEN_UINT8);
      System.out.println("TOKEN_UINT8 " + t.image);
        break;
      case TOKEN_UINT16:
        t = jj_consume_token(TOKEN_UINT16);
      System.out.println("TOKEN_UINT16 " + t.image);
        break;
      case TOKEN_UINT32:
        t = jj_consume_token(TOKEN_UINT32);
      System.out.println("TOKEN_UINT32 " + t.image);
        break;
      case TOKEN_UINT64:
        t = jj_consume_token(TOKEN_UINT64);
      System.out.println("TOKEN_UINT64 " + t.image);
        break;
      case TOKEN_UINTPTR:
        t = jj_consume_token(TOKEN_UINTPTR);
      System.out.println("TOKEN_UINTPTR " + t.image);
        break;
      case TOKEN_TRUE:
        t = jj_consume_token(TOKEN_TRUE);
      System.out.println("TOKEN_TRUE " + t.image);
        break;
      case TOKEN_FALSE:
        t = jj_consume_token(TOKEN_FALSE);
      System.out.println("TOKEN_FALSE " + t.image);
        break;
      case TOKEN_IOTA:
        t = jj_consume_token(TOKEN_IOTA);
      System.out.println("TOKEN_IOTA " + t.image);
        break;
      case TOKEN_APPEND:
        t = jj_consume_token(TOKEN_APPEND);
      System.out.println("TOKEN_APPEND " + t.image);
        break;
      case TOKEN_CAP:
        t = jj_consume_token(TOKEN_CAP);
      System.out.println("TOKEN_CAP " + t.image);
        break;
      case TOKEN_CLOSE:
        t = jj_consume_token(TOKEN_CLOSE);
      System.out.println("TOKEN_CLOSE " + t.image);
        break;
      case TOKEN_COMPLEX:
        t = jj_consume_token(TOKEN_COMPLEX);
      System.out.println("TOKEN_COMPLEX " + t.image);
        break;
      case TOKEN_COPY:
        t = jj_consume_token(TOKEN_COPY);
      System.out.println("TOKEN_COPY " + t.image);
        break;
      case TOKEN_DELETE:
        t = jj_consume_token(TOKEN_DELETE);
      System.out.println("TOKEN_DELETE " + t.image);
        break;
      case TOKEN_IMAG:
        t = jj_consume_token(TOKEN_IMAG);
      System.out.println("TOKEN_IMAG " + t.image);
        break;
      case TOKEN_LEN:
        t = jj_consume_token(TOKEN_LEN);
      System.out.println("TOKEN_LEN " + t.image);
        break;
      case TOKEN_MAKE:
        t = jj_consume_token(TOKEN_MAKE);
      System.out.println("TOKEN_MAKE " + t.image);
        break;
      case TOKEN_NEW:
        t = jj_consume_token(TOKEN_NEW);
      System.out.println("TOKEN_NEW " + t.image);
        break;
      case TOKEN_PANIC:
        t = jj_consume_token(TOKEN_PANIC);
      System.out.println("TOKEN_PANIC " + t.image);
        break;
      case TOKEN_PRINTLN:
        t = jj_consume_token(TOKEN_PRINTLN);
      System.out.println("TOKEN_PRINTLN " + t.image);
        break;
      case TOKEN_PRINT:
        t = jj_consume_token(TOKEN_PRINT);
      System.out.println("TOKEN_PRINT " + t.image);
        break;
      case TOKEN_REAL:
        t = jj_consume_token(TOKEN_REAL);
      System.out.println("TOKEN_REAL " + t.image);
        break;
      case TOKEN_RECOVER:
        t = jj_consume_token(TOKEN_RECOVER);
      System.out.println("TOKEN_RECOVER " + t.image);
        break;
      case TOKEN_BREAK:
        t = jj_consume_token(TOKEN_BREAK);
      System.out.println("TOKEN_BREAK " + t.image);
        break;
      case TOKEN_DEFAULT:
        t = jj_consume_token(TOKEN_DEFAULT);
      System.out.println("TOKEN_DEFAULT " + t.image);
        break;
      case TOKEN_FUNC:
        t = jj_consume_token(TOKEN_FUNC);
      System.out.println("TOKEN_FUNC " + t.image);
        break;
      case TOKEN_INTERFACE:
        t = jj_consume_token(TOKEN_INTERFACE);
      System.out.println("TOKEN_INTERFACE " + t.image);
        break;
      case TOKEN_SELECT:
        t = jj_consume_token(TOKEN_SELECT);
      System.out.println("TOKEN_SELECT " + t.image);
        break;
      case TOKEN_CASE:
        t = jj_consume_token(TOKEN_CASE);
      System.out.println("TOKEN_CASE " + t.image);
        break;
      case TOKEN_DEFER:
        t = jj_consume_token(TOKEN_DEFER);
      System.out.println("TOKEN_DEFER " + t.image);
        break;
      case TOKEN_GO:
        t = jj_consume_token(TOKEN_GO);
      System.out.println("TOKEN_GO " + t.image);
        break;
      case TOKEN_MAP:
        t = jj_consume_token(TOKEN_MAP);
      System.out.println("TOKEN_MAP " + t.image);
        break;
      case TOKEN_STRUCT:
        t = jj_consume_token(TOKEN_STRUCT);
      System.out.println("TOKEN_STRUCT " + t.image);
        break;
      case TOKEN_CHAN:
        t = jj_consume_token(TOKEN_CHAN);
      System.out.println("TOKEN_CHAN " + t.image);
        break;
      case TOKEN_ELSE:
        t = jj_consume_token(TOKEN_ELSE);
      System.out.println("TOKEN_ELSE " + t.image);
        break;
      case TOKEN_GOTO:
        t = jj_consume_token(TOKEN_GOTO);
      System.out.println("TOKEN_GOTO " + t.image);
        break;
      case TOKEN_PACKAGE:
        t = jj_consume_token(TOKEN_PACKAGE);
      System.out.println("TOKEN_PACKAGE " + t.image);
        break;
      case TOKEN_SWITCH:
        t = jj_consume_token(TOKEN_SWITCH);
      System.out.println("TOKEN_SWITCH " + t.image);
        break;
      case TOKEN_CONST:
        t = jj_consume_token(TOKEN_CONST);
      System.out.println("TOKEN_CONST " + t.image);
        break;
      case TOKEN_FALLTHROUGH:
        t = jj_consume_token(TOKEN_FALLTHROUGH);
      System.out.println("TOKEN_FALLTHROUGH " + t.image);
        break;
      case TOKEN_IF:
        t = jj_consume_token(TOKEN_IF);
      System.out.println("TOKEN_IF " + t.image);
        break;
      case TOKEN_RANGE:
        t = jj_consume_token(TOKEN_RANGE);
      System.out.println("TOKEN_RANGE " + t.image);
        break;
      case TOKEN_TYPE:
        t = jj_consume_token(TOKEN_TYPE);
      System.out.println("TOKEN_TYPE " + t.image);
        break;
      case TOKEN_CONTINUE:
        t = jj_consume_token(TOKEN_CONTINUE);
      System.out.println("TOKEN_CONTINUE " + t.image);
        break;
      case TOKEN_FOR:
        t = jj_consume_token(TOKEN_FOR);
      System.out.println("TOKEN_FOR " + t.image);
        break;
      case TOKEN_IMPORT:
        t = jj_consume_token(TOKEN_IMPORT);
      System.out.println("TOKEN_IMPORT " + t.image);
        break;
      case TOKEN_RETURN:
        t = jj_consume_token(TOKEN_RETURN);
      System.out.println("TOKEN_RETURN " + t.image);
        break;
      case TOKEN_VAR:
        t = jj_consume_token(TOKEN_VAR);
      System.out.println("TOKEN_VAR " + t.image);
        break;
      case TOKEN_NIL:
        t = jj_consume_token(TOKEN_NIL);
      System.out.println("TOKEN_NIL " + t.image);
        break;
      case TOKEN_GENERAL_COMMENT:
        t = jj_consume_token(TOKEN_GENERAL_COMMENT);
      System.out.println("TOKEN_GENERAL_COMMENT " + t.image);
        break;
      case TOKEN_RAW_STRING_LITERAL:
        t = jj_consume_token(TOKEN_RAW_STRING_LITERAL);
      System.out.println("TOKEN_RAW_STRING_LITERAL " + t.image);
        break;
      case TOKEN_INTERPRETED_STRING_LITERAL:
        t = jj_consume_token(TOKEN_INTERPRETED_STRING_LITERAL);
      System.out.println("TOKEN_INTERPRETED_STRING_LITERAL " + t.image);
        break;
      case TOKEN_LINE_COMMENT:
        t = jj_consume_token(TOKEN_LINE_COMMENT);
      System.out.println("TOKEN_LINE_COMMENT " + t.image);
        break;
      case TOKEN_DIFFERENT:
        t = jj_consume_token(TOKEN_DIFFERENT);
      System.out.println("TOKEN_DIFFERENT " + t.image);
        break;
      case TOKEN_LESS_EQUAL:
        t = jj_consume_token(TOKEN_LESS_EQUAL);
      System.out.println("TOKEN_LESS_EQUAL " + t.image);
        break;
      case TOKEN_GREATER_EQUAL:
        t = jj_consume_token(TOKEN_GREATER_EQUAL);
      System.out.println("TOKEN_GREATER_EQUAL " + t.image);
        break;
      case TOKEN_SHORT_DECLARATION:
        t = jj_consume_token(TOKEN_SHORT_DECLARATION);
      System.out.println("TOKEN_SHORT_DECLARATION " + t.image);
        break;
      case TOKEN_ELLIPSIS:
        t = jj_consume_token(TOKEN_ELLIPSIS);
      System.out.println("TOKEN_ELLIPSIS " + t.image);
        break;
      case TOKEN_OPEN_PARENTHESIS:
        t = jj_consume_token(TOKEN_OPEN_PARENTHESIS);
      System.out.println("TOKEN_OPEN_PARENTHESIS " + t.image);
        break;
      case TOKEN_CLOSE_PARENTHESIS:
        t = jj_consume_token(TOKEN_CLOSE_PARENTHESIS);
      System.out.println("TOKEN_CLOSE_PARENTHESIS " + t.image);
        break;
      case TOKEN_OPEN_BRACKET:
        t = jj_consume_token(TOKEN_OPEN_BRACKET);
      System.out.println("TOKEN_OPEN_BRACKET " + t.image);
        break;
      case TOKEN_CLOSE_BRACKET:
        t = jj_consume_token(TOKEN_CLOSE_BRACKET);
      System.out.println("TOKEN_CLOSE_BRACKET " + t.image);
        break;
      case TOKEN_OPEN_BRACE:
        t = jj_consume_token(TOKEN_OPEN_BRACE);
      System.out.println("TOKEN_OPEN_BRACE " + t.image);
        break;
      case TOKEN_CLOSE_BRACE:
        t = jj_consume_token(TOKEN_CLOSE_BRACE);
      System.out.println("TOKEN_CLOSE_BRACE " + t.image);
        break;
      case TOKEN_COMMA:
        t = jj_consume_token(TOKEN_COMMA);
      System.out.println("TOKEN_COMMA " + t.image);
        break;
      case TOKEN_SEMICOLON:
        t = jj_consume_token(TOKEN_SEMICOLON);
      System.out.println("TOKEN_SEMICOLON " + t.image);
        break;
      case TOKEN_DOT:
        t = jj_consume_token(TOKEN_DOT);
      System.out.println("TOKEN_DOT " + t.image);
        break;
      case TOKEN_COLON:
        t = jj_consume_token(TOKEN_COLON);
      System.out.println("TOKEN_COLON " + t.image);
        break;
      case TOKEN_AND:
        t = jj_consume_token(TOKEN_AND);
      System.out.println("TOKEN_AND " + t.image);
        break;
      case TOKEN_OR:
        t = jj_consume_token(TOKEN_OR);
      System.out.println("TOKEN_OR " + t.image);
        break;
      case TOKEN_CHANNEL_DIRECTION:
        t = jj_consume_token(TOKEN_CHANNEL_DIRECTION);
      System.out.println("TOKEN_CHANNEL_DIRECTION " + t.image);
        break;
      case TOKEN_PLUS_PLUS:
        t = jj_consume_token(TOKEN_PLUS_PLUS);
      System.out.println("TOKEN_PLUS_PLUS " + t.image);
        break;
      case TOKEN_MINUS_MINUS:
        t = jj_consume_token(TOKEN_MINUS_MINUS);
      System.out.println("TOKEN_MINUS_MINUS " + t.image);
        break;
      case TOKEN_BIT_AND_NOT_ASSIGN:
        t = jj_consume_token(TOKEN_BIT_AND_NOT_ASSIGN);
      System.out.println("TOKEN_BIT_AND_NOT_ASSIGN " + t.image);
        break;
      case TOKEN_BIT_AND_ASSIGN:
        t = jj_consume_token(TOKEN_BIT_AND_ASSIGN);
      System.out.println("TOKEN_BIT_AND_ASSIGN " + t.image);
        break;
      case TOKEN_BIT_OR_ASSIGN:
        t = jj_consume_token(TOKEN_BIT_OR_ASSIGN);
      System.out.println("TOKEN_BIT_OR_ASSIGN " + t.image);
        break;
      case TOKEN_BIT_XOR_ASSIGN:
        t = jj_consume_token(TOKEN_BIT_XOR_ASSIGN);
      System.out.println("TOKEN_BIT_XOR_ASSIGN " + t.image);
        break;
      case TOKEN_LEFT_SHIFT_ASSIGN:
        t = jj_consume_token(TOKEN_LEFT_SHIFT_ASSIGN);
      System.out.println("TOKEN_LEFT_SHIFT_ASSIGN " + t.image);
        break;
      case TOKEN_RIGHT_SHIFT_ASSIGN:
        t = jj_consume_token(TOKEN_RIGHT_SHIFT_ASSIGN);
      System.out.println("TOKEN_RIGHT_SHIFT_ASSIGN " + t.image);
        break;
      case TOKEN_PLUS_ASSIGN:
        t = jj_consume_token(TOKEN_PLUS_ASSIGN);
      System.out.println("TOKEN_PLUS_ASSIGN " + t.image);
        break;
      case TOKEN_MINUS_ASSIGN:
        t = jj_consume_token(TOKEN_MINUS_ASSIGN);
      System.out.println("TOKEN_MINUS_ASSIGN " + t.image);
        break;
      case TOKEN_MULTIPLY_ASSIGN:
        t = jj_consume_token(TOKEN_MULTIPLY_ASSIGN);
      System.out.println("TOKEN_MULTIPLY_ASSIGN " + t.image);
        break;
      case TOKEN_DIVIDE_ASSIGN:
        t = jj_consume_token(TOKEN_DIVIDE_ASSIGN);
      System.out.println("TOKEN_DIVIDE_ASSIGN " + t.image);
        break;
      case TOKEN_REMAINDER_ASSIGN:
        t = jj_consume_token(TOKEN_REMAINDER_ASSIGN);
      System.out.println("TOKEN_REMAINDER_ASSIGN " + t.image);
        break;
      case TOKEN_BIT_AND_NOT:
        t = jj_consume_token(TOKEN_BIT_AND_NOT);
      System.out.println("TOKEN_BIT_AND_NOT " + t.image);
        break;
      case TOKEN_BIT_AND:
        t = jj_consume_token(TOKEN_BIT_AND);
      System.out.println("TOKEN_BIT_AND " + t.image);
        break;
      case TOKEN_BIT_OR:
        t = jj_consume_token(TOKEN_BIT_OR);
      System.out.println("TOKEN_BIT_OR " + t.image);
        break;
      case TOKEN_BIT_XOR:
        t = jj_consume_token(TOKEN_BIT_XOR);
      System.out.println("TOKEN_BIT_XOR " + t.image);
        break;
      case TOKEN_LEFT_SHIFT:
        t = jj_consume_token(TOKEN_LEFT_SHIFT);
      System.out.println("TOKEN_LEFT_SHIFT " + t.image);
        break;
      case TOKEN_RIGHT_SHIFT:
        t = jj_consume_token(TOKEN_RIGHT_SHIFT);
      System.out.println("TOKEN_RIGHT_SHIFT " + t.image);
        break;
      case TOKEN_PLUS:
        t = jj_consume_token(TOKEN_PLUS);
      System.out.println("TOKEN_PLUS " + t.image);
        break;
      case TOKEN_MINUS:
        t = jj_consume_token(TOKEN_MINUS);
      System.out.println("TOKEN_MINUS " + t.image);
        break;
      case TOKEN_MULTIPLY:
        t = jj_consume_token(TOKEN_MULTIPLY);
      System.out.println("TOKEN_MULTIPLY " + t.image);
        break;
      case TOKEN_DIVIDE:
        t = jj_consume_token(TOKEN_DIVIDE);
      System.out.println("TOKEN_DIVIDE " + t.image);
        break;
      case TOKEN_REMAINDER:
        t = jj_consume_token(TOKEN_REMAINDER);
      System.out.println("TOKEN_REMAINDER " + t.image);
        break;
      case TOKEN_EQUAL:
        t = jj_consume_token(TOKEN_EQUAL);
      System.out.println("TOKEN_EQUAL " + t.image);
        break;
      case TOKEN_LESS:
        t = jj_consume_token(TOKEN_LESS);
      System.out.println("TOKEN_LESS " + t.image);
        break;
      case TOKEN_GREATER:
        t = jj_consume_token(TOKEN_GREATER);
      System.out.println("TOKEN_GREATER " + t.image);
        break;
      case TOKEN_ASSIGN:
        t = jj_consume_token(TOKEN_ASSIGN);
      System.out.println("TOKEN_ASSIGN " + t.image);
        break;
      case TOKEN_NOT:
        t = jj_consume_token(TOKEN_NOT);
      System.out.println("TOKEN_NOT " + t.image);
        break;
      case TOKEN_TILDE:
        t = jj_consume_token(TOKEN_TILDE);
      System.out.println("TOKEN_TILDE " + t.image);
        break;
      case TOKEN_BINARY_LITERAL:
        t = jj_consume_token(TOKEN_BINARY_LITERAL);
      System.out.println("TOKEN_BINARY_LITERAL " + t.image);
        break;
      case TOKEN_OCTAL_LITERAL:
        t = jj_consume_token(TOKEN_OCTAL_LITERAL);
      System.out.println("TOKEN_OCTAL_LITERAL " + t.image);
        break;
      case TOKEN_DECIMAL_LITERAL:
        t = jj_consume_token(TOKEN_DECIMAL_LITERAL);
      System.out.println("TOKEN_DECIMAL_LITERAL " + t.image);
        break;
      case TOKEN_HEX_LITERAL:
        t = jj_consume_token(TOKEN_HEX_LITERAL);
      System.out.println("TOKEN_HEX_LITERAL " + t.image);
        break;
      case TOKEN_DECIMAL_FLOAT_LITERAL:
        t = jj_consume_token(TOKEN_DECIMAL_FLOAT_LITERAL);
      System.out.println("TOKEN_DECIMAL_FLOAT_LITERAL " + t.image);
        break;
      case TOKEN_HEX_FLOAT_LITERAL:
        t = jj_consume_token(TOKEN_HEX_FLOAT_LITERAL);
      System.out.println("TOKEN_HEX_FLOAT_LITERAL " + t.image);
        break;
      case TOKEN_IMAGINARY_LITERAL:
        t = jj_consume_token(TOKEN_IMAGINARY_LITERAL);
      System.out.println("TOKEN_IMAGINARY_LITERAL " + t.image);
        break;
      case TOKEN_RUNE_LITERAL:
        t = jj_consume_token(TOKEN_RUNE_LITERAL);
      System.out.println("TOKEN_RUNE_LITERAL " + t.image);
        break;
      case TOKEN_IDENTIFIER:
        t = jj_consume_token(TOKEN_IDENTIFIER);
      System.out.println("TOKEN_IDENTIFIER " + t.image);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(0);
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public CompiladorTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[2];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static private int[] jj_la1_5;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
      jj_la1_init_5();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xfffe004a,0xfffe004a,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0xffffffff,0xffffffff,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0xf807ffff,0xf807ffff,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0xffffffff,0xffffffff,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0xb0f0fff,0xb0f0fff,};
   }
   private static void jj_la1_init_5() {
      jj_la1_5 = new int[] {0x28,0x28,};
   }

  /** Constructor with InputStream. */
  public Compilador(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Compilador(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new CompiladorTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Compilador(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new CompiladorTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Compilador(CompiladorTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(CompiladorTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List jj_expentries = new java.util.ArrayList();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[166];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 2; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 166; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
